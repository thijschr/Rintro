```{r setup, include = FALSE}
opts_chunk$set(cache = TRUE)
```

Data structures of R
========================================================
author: Thijs Christiaan van Son
date: 

Overview: Data structures
========================================================
type: section

Dim | Homogeneous | Heterogeneous
--- | ----------- | -------------
1d  | Atomic vector | List
2d  | Matrix      | Data frame
nd  | Array       | 

- *Homogeneous*: ...
- *Heterogeneous*: ...

Vectors
========================================================
type: section

- The fundamental data type in R  
- Consists of two basic flavours: *atomic vector* and *lists*
- **OBS!** Use str(), short for structure, when trying to understand 
the structure of any R data structure

Properties of vectors
========================================================
```{r, vectorProperties, eval = FALSE}
# Vectors have three properties
typeof()           # What it is
length()           # How long it is
attributes()       # Additional metadata
names()            # The most common attribute

# Testing and coercing
is.vector()                  # Testing
is.atomic() || is.list()     # Best test
as.vector()                  # Coercing into a vector
```
**OBS!** is.vector() returns TRUE only if it is a vector with no
attributes apart from names

Atomic vectors
========================================================
- logical
- integer  
- numeric
- character

```{r, vectorTypes, eval = TRUE}
log <- c(TRUE, FALSE, FALSE, TRUE)
num <- c(1.2, 3.0, 3.9, 2.4)
# Note the L suffix which distinguishes numeric from integers
int <- c(1L, 3L, 2L, 7L)
char <- c("these", "are", "some", "strings")
```

seq()
========================================================
```{r, sequence, eval = TRUE}
seq(from = 0, to = 10, by = 2)
seq(from = 0, to = 1, length = 11)
```
**OBS!** seq() is handy to use in loops

rep()
========================================================
```{r, repeat, eval = TRUE}
rep(x = NA, times = 7)
rep(x = c(5, 6, 7), times = 3)
```
**OBS!** Can be handy for specifying an empty vector of a certain length
that can be filled by, for example data generated by loops, later

Using NULL
========================================================
One can use NULL to build up vectors in loops
```{r, NULL, eval = TRUE}
z <- NULL
for(i in seq(10)) if(i %%2 == 0) z <- c(z, i)
z
```
- %% is the modulo operator, giving reminders upon division  
- **OBS!** This is an artificial example

NA vs. NULL
========================================================
Null values are counted as nonexistent
```{r, NULLvsNA, eval = TRUE}
u <- NULL
length(u)
v <- NA
length(v)
```
Indexing
========================================================
Data structures in R are indexed
```{r, indexing, eval = TRUE}
num
num[1]
num[2:3]
```

Negative indexing
========================================================
```{r, negIndexing, eval = TRUE}
num
num[-1]
num[-c(1, 3)]
```

Filtering
========================================================
Extract vector elements satisfying conditions
```{r, filter, eval = TRUE}
num
num[num*num > 4]
num[num == 0]
```

Filtering by logical vector
========================================================
```{r, filterLogical, eval = TRUE}
num
sel <- num*num >= 9
sel
num[sel]
```

Test of vector equality
========================================================
```{r, vectorEquality, eval = TRUE}
num
(num2 <- c(1.1, 3.0, 3.6, 2.7))
num == num2
```

Adding or deleting elements
========================================================
- The size of a vector is determined when it is created
- To add or delete elements, you'll need to reassign the vector  
```{r, adding, eval = TRUE}
x <- c(3, 6, 4, 9)
x
x <- c(x[1:3], 13, x[4])
x
```

Factors: dealing with qual data
========================================================
```{r, factor, eval = TRUE}
x <- factor(c("a", "a", "b", "c"))
x
class(x)
levels(x)
```

Recycling
========================================================
**OBS!** R will recycle the shorter vector if combined with
a longer vector
```{r, recycling, eval = TRUE}
# Will issue a warning message!
c(2, 4, 6) + c(4, 0, 5, 3, 1)
# The shorter vector was recycled like:
c(2, 4, 6, 2, 4) + c(4, 0, 5, 3, 1)
```

Vector element names
========================================================
Vectors can be given names in three ways:
```{r, vectornames, eval = TRUE}
x <- c(a = 1, b = 2, c = 3)
x <- c(1:3); names(x) <- c("a", "b", "c")
x <- setNames(1:3, c("a", "b", "c"))
x
unname(x)          # Removal of names
```

Exercise: Atomic vectors
========================================================
type: alert
1. Create vectors using different methods such as c(), seq(), and rep()
2. Extract different elements of the vectors using indexing (also negative indexing)
3. Create a factor vector
4. Create two vectors of unequal length
  - Combine them using mathematical operations

Any questions?
========================================================
type: prompt

Matrices
========================================================
type: section
- A *matrix* is a vector with two additional attributes:
  - the number of rows
  - the number of columns
- **Remember** - a matrix is a *homogeneous* data type

Creating matrices
========================================================
- Subscripts of rows and columns starts with 1
- Unless told differently, R stores a matrix column-wise
- One way to create a matrix is by using the **matrix()** function

Creating matrices using matrix()
========================================================
```{r, creatingMatrices, eval = TRUE}
y <- matrix(c(1, 4, 7, 10), nrow = 2, ncol = 2)
y
```

Storing matrices by row
========================================================
```{r, matricesByRow, eval = TRUE}
z <- matrix(c(1, 4, 7, 10), nrow = 2, byrow = T)
z
y        # Compare with by column
```

Creating an empty matrix
========================================================
```{r, emptyMatrix, eval = TRUE}
e <- matrix(data = NA, ncol = 3, nrow = 3,
            dimnames=list(c("a", "b", "c"), 
                          c("x", "y", "z")
                          )
            )
e
```
- ***OBS!*** Watch the automatic indentation of brackets
- Handy because you can populate the matrix with data later on

Matrix indexing
========================================================
```{r, matrixIndexing, eval = TRUE}
z
z[1, 2] # Always row subscript first
z[, 2]  # Empty subscript = all rows or cols
```

Matrix filtering
========================================================
```{r, matrixFilt, eval = TRUE}
z
z[z[, 1] == 7, ]
z[, z[2, ] >= 9]
```

Matrix filtering: Ex 2
========================================================
```{r, matrixFiltII, eval = TRUE}
z
(f <- z[1, ] >= 4)      # Returns logical
z[, f]
```

Applying functions to rows and columns
========================================================
The **apply()** function  
- apply(X, MARGIN, FUN)
  - X is the matrix
  - MARGIN is the dimension
  - FUN the function to be applied

**OBS!** There are several *apply() functions

apply() example
========================================================
```{r, matrixApply, eval = TRUE}
z
apply(X = z, MAR = 1, sum)
apply(X = z, MAR = 2, function(x) sum(x > 5))
```

Adding and deleting rows and columns
========================================================
- Matrices have fixed dimensions
  - Thus, we cannot add or delete rows or columns
- Solution: *reassign* the matrix
  - Provides the same affect as if we had added or deleted
  rows and/or columns

A matrix is just a vector, but ...
========================================================
```{r, matrixIsVectBut, eval = TRUE}
(x <- c(1, 4, 7, 10))
z
```

A matrix is just a vector, but ... II
========================================================
Vector *x* and matrix *z* have the same length:
```{r, matrixIsVectButII, eval = TRUE}
length(x)     # Length of vector x
length(z)     # Length of matrix z
```

A matrix is just a vector, but ... III
========================================================
But are different:
```{r, matrixIsVectButIII, eval = TRUE}
str(x)      # Class of vector
str(z)      # Class of matrix
```

Names of rows and columns
========================================================
- The natural way to refer to rows and columns in a matrix is by use of row and column numbers
- The **colnames()** and **rownames()** functions provide means of naming rows and columns of a matrix
- It is especially handy to give column and row names when you want to inspect the contents of the matrix

Names of rows and columns II
========================================================
```{r, rowColNamesMatrix, eval = TRUE}
colnames(z) <- c("speciesA", "speciesB")
rownames(z) <- c("1", "2")
z
str(z)
```

c() and cbind()
========================================================
```{r, cCbindRbind, eval = TRUE}
x <- 1:3; y <- 4:6
(v <- c(x, y))
str(v); is.matrix(v)
```

c() and cbind() II
========================================================
```{r, cCbindRbindII, eval = TRUE}
(w <- cbind(x, y))
str(w); is.matrix(w)
```

Exercise: Matrices
========================================================
type: alert
1. Create matrices of different dimensions using **matrix()**, **cbind()**, and **rbind()**
2. What is the default way of storing data in a matrix using **matrix()**? By column or by row?
3. Make sure you are able to store data in a matrix both by column and row
4. From your created matrices, extract single values, columns, and rows
5. Filter your matrices by applying a condition/target/cut-off value

Any questions?
========================================================
type: prompt
Regarding matrices

Data frame
========================================================
type: section
Matrix-like, but for heterogeneous data  
Creating data frames from scratch  
Read a csv file to see the output  
Accessing data frames by subscripts and by column names, names()    
Keeping as data frame (not vector)  
head()/tail()  
str()  


Lists
========================================================
type: section


