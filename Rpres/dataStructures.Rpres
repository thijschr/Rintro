```{r setup, include = FALSE}
opts_chunk$set(cache = FALSE)
```

Data structures of R
========================================================
author: Thijs Christiaan van Son
date: 

Overview: Data structures
========================================================
type: section

Dim | Homogeneous | Heterogeneous
--- | ----------- | -------------
1d  | Atomic vector | List
2d  | Matrix      | Data frame
nd  | Array       | 

- *Homogeneous*: Contents must be of the same type
- *Heterogeneous*: Contents can be of different type  

We will talk about all these data structures, except arrays

Vectors
========================================================
type: section

- The fundamental data type in R  
- Consists of two basic flavours: *atomic vector* and *lists*
  - First we look at *atomic vectors*, while we will introduce *lists* in the end
- **OBS!** Use str(), short for structure, when trying to understand 
the structure of any R data structure

Properties of vectors
========================================================
```{r, vectorProperties, eval = FALSE}
# Vectors have three properties
typeof()           # What it is
length()           # How long it is
attributes()       # Additional metadata
names()            # Most common attribute

# Testing and coercing
is.vector()                  # Testing
is.atomic() || is.list()     # Best test
as.vector()                  # Coercing into a vector
```
**OBS!** is.vector() returns TRUE only if it is a vector with no
attributes apart from names

Atomic vectors
========================================================
Can be:
- logical
- integer  
- numeric
- character

```{r, vectorTypes, eval = TRUE}
log <- c(TRUE, FALSE, FALSE, TRUE)
num <- c(1.2, 3.0, 3.9, 2.4)
# Note the L suffix which distinguishes numeric from integers
int <- c(1L, 3L, 2L, 7L)
char <- c("these", "are", "some", "strings")
```

seq()
========================================================
A common way of creating a vector is by use of the **c()** 
(concatenate) function, but **seq()** is also often used
```{r, sequence, eval = TRUE}
seq(from = 0, to = 10, by = 2)
seq(from = 0, to = 1, length = 11)
```
**OBS!** As we will see later, seq() is handy to use in loops

rep()
========================================================
**rep()** is also a common way of creating a vector
```{r, repeat, eval = TRUE}
rep(x = NA, times = 7)
rep(x = c(5, 6, 7), times = 3)
```
**OBS!** Can be handy for specifying an empty vector of a certain length
that can be filled by, for example data generated by loops, later

Using NULL
========================================================
One can use NULL to build up vectors in loops
```{r, NULL, eval = TRUE}
z <- NULL
for(i in seq(10)) if(i %%2 == 0) z <- c(z, i)
z
```
- %% is the modulo operator, giving reminders upon division  
- **OBS!** This is an artificial example - How could we have made this vector
in a more efficient and elegant way?
- Creating a NULL vector like this is not recommended if the final vector is very long. It is inefficient in terms of speed

NA vs. NULL
========================================================
Null values are counted as nonexistent
```{r, NULLvsNA, eval = TRUE}
u <- NULL
length(u)
v <- NA
length(v)
```

Indexing
========================================================
Data structures in R are indexed
```{r, indexing, eval = TRUE}
num
num[1]
num[2:3]
```

Negative indexing
========================================================
```{r, negIndexing, eval = TRUE}
num
num[-1]
num[-c(1, 3)]
```

Filtering
========================================================
Extract vector elements satisfying conditions
```{r, filter, eval = TRUE}
num
num[num*num > 4]
num[num == 0]
```

Filtering by logical vector
========================================================
```{r, filterLogical, eval = TRUE}
num
sel <- num*num >= 9
sel
num[sel]
```

Test of vector equality
========================================================
```{r, vectorEquality, eval = TRUE}
num
(num2 <- c(1.1, 3.0, 3.6, 2.7))
num == num2
```

Adding or deleting elements
========================================================
- The size of a vector is determined when it is created
- To add or delete elements, you'll need to reassign the vector  
```{r, adding, eval = TRUE}
x <- c(3, 6, 4, 9)
x
x <- c(x[1:3], 13, x[4])
x
```

Vectors of qualitative data
========================================================
```{r, factor, eval = TRUE}
x <- factor(c("a", "a", "b", "c"))
x
class(x)
levels(x)
```

Recycling
========================================================
**OBS!** R will recycle the shorter vector if combined with
a longer vector
```{r, recycling, eval = TRUE}
# Will issue a warning message!
c(2, 4, 6) + c(4, 0, 5, 3, 1)
# The shorter vector was recycled like:
c(2, 4, 6, 2, 4) + c(4, 0, 5, 3, 1)
```

More on NA values
========================================================
Look at this example with missing data (i.e., NA):
```{r, naHandling, eval = TRUE}
n <- c(3, 5, NA, 8, 4)
n
mean(n)
mean(n, na.rm = TRUE)
```

Vector element names
========================================================
Vectors can be given names in three ways:
```{r, vectornames, eval = TRUE}
x <- c(a = 1, b = 2, c = 3)
x <- c(1:3); names(x) <- c("a", "b", "c")
x <- setNames(1:3, c("a", "b", "c"))
x
unname(x)          # Removal of names
```

Exercise: Atomic vectors
========================================================
type: alert
1. Create vectors using different methods such as c(), seq(), and rep()
2. Extract different elements of the vectors using indexing (also negative indexing)
3. Apply some filtering on some of the created vectors
4. Create a factor vector
5. Create two vectors of unequal length
  - Combine them using mathematical operations

Any questions?
========================================================
type: prompt

Regarding (atomic) vectors

Matrices
========================================================
type: section
- A *matrix* is a vector with two additional attributes:
  - the number of rows
  - the number of columns
- **Remember:** a matrix is a *homogeneous* data type
  - What does that mean again?

Creating matrices
========================================================
- We can use the **matrix()** function to create a matrix from scratch
- Unless told differently, R stores a matrix column-wise
- Just like for vectors, subscripts or indices of rows and columns in a matrix
starts with 1

Creating a matrix using matrix()
========================================================
```{r, creatingMatrices, eval = TRUE}
y<-matrix(c(1, 4, 7, 10), nrow = 2, ncol = 2)
y
as.vector(y)  # Recovering the input vector
```
- What happened here?  
- In this case, do I have to specify both the nrow and ncol arguments?


Storing matrices by row
========================================================
```{r, matricesByRow, eval = TRUE}
z<-matrix(c(1, 4, 7, 10), nrow=2, byrow=T)
z
y        # Compare with by column
```

Creating an "empty" matrix
========================================================
```{r, emptyMatrix, eval = TRUE}
e <- matrix(data = NA, ncol = 3, nrow = 3,
            dimnames=list(c("a", "b", "c"), 
                          c("x", "y", "z")
                          )
            )
e
```
- This is handy because you can populate the matrix with data later on
- ***OBS!*** Watch the automatic indentation of brackets


Matrix indexing
========================================================
```{r, matrixIndexing, eval = TRUE}
z
z[1, 2] # Always row subscript first
z[, 2]  # Empty subscript = all rows or cols
```

Matrix filtering
========================================================
```{r, matrixFilt, eval = TRUE}
z
z[z >= 3]
z[z[, 1] == 7, ]   # OBS! z[rows, cols]
```

Matrix filtering: Ex 2
========================================================
```{r, matrixFiltII, eval = TRUE}
z
(f <- z[1, ] >= 4)      # Returns logical
z[, f]
```

Applying functions to rows and columns
========================================================
The **apply()** function  
- apply(X, MARGIN, FUN)
  - X is the matrix
  - MARGIN is the dimension
  - FUN the function to be applied

**OBS!** There are several *apply() functions

apply() example
========================================================
```{r, matrixApply, eval = TRUE}
z
apply(X = z, MAR = 1, sum)
apply(X = z, MAR = 2, function(x) sum(x > 5))
```

Adding and deleting rows and columns
========================================================
- Matrices have fixed dimensions
  - Thus, we cannot add or delete rows or columns
- Solution: *reassign* the matrix
  - Provides the same affect as if we had added or deleted
  rows and/or columns

A matrix is just a vector, but ...
========================================================
```{r, matrixIsVectBut, eval = TRUE}
(x <- c(1, 4, 7, 10))
z
```

A matrix is just a vector, but ... II
========================================================
Vector *x* and matrix *z* have the same length:
```{r, matrixIsVectButII, eval = TRUE}
length(x)     # Length of vector x
length(z)     # Length of matrix z
```

A matrix is just a vector, but ... III
========================================================
... They are different:
```{r, matrixIsVectButIII, eval = TRUE}
str(x)      # Class of vector
str(z)      # Class of matrix
```

Names of rows and columns
========================================================
- The natural way to refer to rows and columns in a matrix is by use of row and column numbers
- The **colnames()** and **rownames()** functions provide means of naming rows and columns of a matrix
- It is especially handy to give column and row names when you want to inspect the contents of the matrix
- As well as when you simply want to be reminded what is stored in the rows and columns

Names of rows and columns II
========================================================
```{r, rowColNamesMatrix, eval = TRUE}
colnames(z) <- c("speciesA", "speciesB")
rownames(z) <- c("1", "2")
z
str(z)   # The dimnames attribute added
```

c() and cbind()
========================================================
```{r, cCbindRbind, eval = TRUE}
x <- 1:3; y <- 4:6
(v <- c(x, y))
str(v); is.matrix(v)
```

c() and cbind() II
========================================================
```{r, cCbindRbindII, eval = TRUE}
(w <- cbind(x, y))
str(w); is.matrix(w)
```

Exercise: Matrices
========================================================
type: alert
1. Create matrices of different dimensions using **matrix()**, **cbind()**, and **rbind()**
2. What is the default way of storing data in a matrix using **matrix()**? By column or by row?
3. Make sure you are able to store data in a matrix both by column and row
4. From your created matrices, extract single values, columns, and rows
5. Filter your matrices by applying a condition/target/cut-off value

Any questions?
========================================================
type: prompt
Regarding matrices

Data frame
========================================================
type: section
- Data frames are very common in R  
- Matrix-like, but they are *heterogeneous*  
- Technically they are also lists, in which each component are equal length vectors  
 

Creating data frames
========================================================
```{r, createDF, eval = TRUE}
spA <- c(0, 0, 0, 1, 0, 1, 1)
spB <- c(0, 1, 1, 0, 0, 0, 0)
spC <- c(1, 0, 0, 0, 1, 0, 0)
obs <- data.frame(speciesA = spA,
                  speciesB = spB,
                  speciesC = spC)
obs
```

Input of tabular data
========================================================
I recommend using **.csv**-files  
```{r, readCsv, eval = TRUE}
env<-read.csv("../data/envVarSomeRaw.csv",
              header = TRUE)
env      # This is a data frame
```

Output of tabular data
========================================================
Writing tabular data to a **.csv**-file
```{r, writeCsv, eval = TRUE}
write.csv(x = obs, 
          file = "../data/speciesObs.csv",
          row.names = FALSE)
```
- *x* is the object to be written
  - It is the *obs* object we just made
- *file* is the file you want the data to be written to
  - Use of paths relative to our project directory
- Excluding the rownames can often be wise

Inspection of data frames
========================================================
```{r, strDF, eval = TRUE}
str(env[c(1:5), ])
```
- **OBS!** For brevity I am only showing the first five observations
- Always use the **str()** function to make sure your data is in the format you intend and want it to be

Inspection of data frames II
========================================================
```{r, headDF, eval = TRUE}
head(env, 3)  # First three observations
tail(env, 3)  # Last three observations
```

Data frame manipulation using dplyr package
========================================================
```{r dplyrLoad, echo=FALSE}
library(dplyr)
```
The dplyr package contains four basic functions for manipulation of data frames
- **filter()**
- **arrange()**
- **select()**
- **mutate()**

dplyr: filter()
========================================================
**filter()** allows you to select a SUBSET of the rows of a data frame. There exist alternative ways of filtering, e.g., the **subset()** function.
```{r dplyrFilter}
filter(env, Depth > 50)
```

dplyr: filter() II
========================================================
Filtering conditions can be joined together
```{r dplyrFilterII}
filter(env, CN >= 11 & BMD >= 1.0)
filter(env, Depth > 70 | TN > 0.4)
```

dplyr: arrange()
========================================================
**arrange()** works similarly to **filter()** except that instead of filtering or selecting rows, it reorders them.
```{r dplyrArrange}
arrange(env, Depth)
```

dplyr: arrange() II
========================================================
**arrange()** can also reorder in descending order.
```{r dplyrArrangeII}
arrange(env, desc(Mud))
```

dplyr: select()
========================================================
**select()** allows you to select only the variables of interest.
```{r dplyrSelect}
select(env, CN, BMD, Depth)
```

dplyr: select() II
========================================================
Its possible to select a sequence of variables
```{r dplyrSelectII}
select(env, TN:TOC, Mud:Depth)
```

dplyr: mutate()
========================================================
**mutate()** allows you to add new columns that are functions of other columns
```{r dplyrMutate}
mutate(env, CN2 = TOC/TN)
```

dplyr: transmute()
========================================================
**transmute()** drops existing variables
```{r dplyrTransmute, results='hide'}
transmute(env, CN2 = TOC/TN)
```
```{r dplyrTransmuteII}
head(env)
```

Adding a variable (not function of others)
========================================================
```{r, addColDF, eval = TRUE}
# Adding a column
env$index <- 1:10
env
```

Alternative for removing a column
========================================================
```{r, remColDF, eval = TRUE}
env <- env[, -7]   # Easiest by col number
env
```

Accessing data frames
========================================================
```{r, acessDFsubScripts, eval = TRUE}
# Extracting by subscripts
env[1:5, 6]
# Extracting by column name
names(env)    # Handy function
env$Depth[1:5]
```

Avoiding dimension reduction
========================================================
```{r, dimRedDF, eval = TRUE}
# Extracting a one-dimensional subset returns a vector
env$TN[1:5]
str(env$TN[1:5])
is.vector(env$TN[1:5])
```

Avoiding dimension reduction II
========================================================
```{r, dimRedDFII, eval = TRUE}
# Apply the drop = FALSE argument to avoid dimension reduction
env[1:5, 1, drop = FALSE]
is.data.frame(env[1:5, 1, drop = FALSE])
```

Exercises: Data frames
========================================================
type: alert
1. Create a few vectors and combine them in a data frame using the **data.frame()** function
2. Load the envVarAllZST.csv file in the data directory
  - Inspect the structure of the data frame
  - Access subsets of the data by subscripts and by column name
  - Do some filtering on the data frame
  - Write the filtered data to a .csv file using the **write.csv()** function
  - Open the created .csv file in a text editor
3. Perform correlation tests using the **cor.test()** function

Any questions?
========================================================
type: prompt
Regarding data frames

Lists
========================================================
type: section
- Just as data frames, lists are **heterogeneous**
- As we said when talking about vectors, technically, lists are vectors
- As we will see later, the output of functions is often summarised in lists

Creating lists
========================================================
```{r, createList, eval = TRUE}
L <- list(name = c("Kim", "Oda", "Ola"),
          age = c(19, 23, 25),
          nationality = c("DE", "N", "N"))
L
```

List tags are optional
========================================================
```{r, createListII, eval = TRUE}
# A list without tags
L2 <- list(c("Kim", "Oda", "Ola"),
           c(19, 23, 25),
           c("S", "DK", "N"))
L2
``` 

Structure of a list
========================================================
```{r, strList, eval = TRUE}
str(L)
str(L2)
``` 

Accessing list components
========================================================
```{r, listAccess, eval = TRUE}
# Three ways to access individual components of a list
L$name
L[["name"]]
L[[1]]
``` 

Accessing list values
========================================================
```{r, listAccessII, eval = TRUE}
# Three ways to access values of a list
L$name[1]
L[["name"]][1:2]
L[[1]][c(1, 3)]
``` 

Modelling output is a list
========================================================
```{r, envModelling, eval = TRUE}
# Fitting a linear model
mod <- lm(Mud ~ Depth, data = env)

# Is the mod object a list?
is.list(mod)
# str(mod)    # Not shown due to size
``` 

Modelling output is a list II
========================================================
```{r, envModellingII, eval = TRUE}
names(mod)
mod$coefficients   # Accessing output
``` 

lapply() and sapply() functions
========================================================
```{r, applyOnLists, eval = TRUE}
# Creating a new list
L3 <- list(c(4:6),
           c(13:17))
L3
``` 

lapply() and sapply() functions II
========================================================
```{r, lapply, eval = TRUE}
# lapply() on a list
lapply(L3, sum)
# sapply() returns a vector
# Which in some cases can be more desirable
sapply(L3, sum)
``` 

Exercises: Lists
========================================================
type: alert
1. Create a list, with tags, that contains four components, one for each of the major data types: vector, matrix, data frame, and list
2. Look at the structure of the list
3. Access list components and list values
4. Specify and run a linear model using data from the envVarAllZST.csv file that you imported earlier
  - Extract and inspect the coefficients, residuals and fitted values
  - plot the residuals vs. the fitted values

Any questions?
========================================================
type: prompt

List or data structure/type in general?
